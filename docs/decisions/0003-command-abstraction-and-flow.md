# ADR-0003: Command Abstraction and Flow

## Status

Accepted

## Context

NeoHaskell implements an Event Sourcing / CQRS architecture where commands are the primary entry point for mutations. This ADR documents the command abstraction layer, focusing on:

1. How commands are defined and what makes them valid
2. How decisions are made (accept/reject logic)
3. How entities are reconstructed to inform decisions
4. How commands are executed through the CommandHandler

This document focuses on the domain-level abstractions, independent of transport (HTTP, CLI) or persistence (InMemory, Postgres) implementations.

## Decision

### 1. The Command Abstraction

A **Command** represents a user's intent to change the system. Commands are validated against the current state of an entity and either accepted (producing events) or rejected (with a reason).

#### 1.1 The Command Typeclass

The `Command` typeclass (`Service.Command.Core`) defines the contract for all commands:

```haskell
class Command command where
  type IsMultiTenant command :: Bool
  type IsMultiTenant command = False

  getEntityIdImpl :: GetEntityIdFunction (IsMultiTenant command) command (EntityIdType (EntityOf command))
  decideImpl :: DecideFunction (IsMultiTenant command) command (EntityOf command) (EventOf (EntityOf command))
```

Key observations:
- `getEntityIdImpl` extracts the entity identifier from the command (or returns `Nothing` for creation commands)
- `decideImpl` contains the pure business logic that determines whether to accept or reject
- Multi-tenancy support is opt-in via the `IsMultiTenant` type family

#### 1.2 Associated Type Families

Commands use type families to establish relationships between types:

| Type Family | Purpose | Example |
|-------------|---------|---------|
| `EntityOf command` | Which entity type this command operates on | `type instance EntityOf CreateCart = CartEntity` |
| `EventOf entity` | Which event type this entity produces | `type instance EventOf CartEntity = CartEvent` |
| `ApiOf command` | Which API exposes this command | `type instance ApiOf CreateCart = WebApi` |
| `NameOf command` | Type-level string for the command name | Generated by TH as `"CreateCart"` |
| `EntityIdType entity` | The type of the entity's identifier | Defaults to `Uuid` |

These type families enable type-safe composition at compile time.

#### 1.3 Defining a Command

A complete command definition requires:

```haskell
-- 1. The command data type
data CreateCart = CreateCart
  deriving (Generic, Typeable, Show)

-- 2. JSON deserialization (for API transport)
instance Json.FromJSON CreateCart

-- 3. Type family instances
type instance EntityOf CreateCart = CartEntity
type instance ApiOf CreateCart = WebApi

-- 4. Entity ID extraction function
getEntityId :: CreateCart -> Maybe Uuid
getEntityId _ = Nothing  -- No existing entity for creation

-- 5. Decision logic
decide :: CreateCart -> Maybe CartEntity -> Decision CartEvent
decide _ entity = do
  case entity of
    Just _ -> Decision.reject "Cart already exists!"
    Nothing -> do
      id <- Decision.generateUuid
      Decision.acceptNew [CartCreated {entityId = id}]

-- 6. Template Haskell splice to generate Command instance
command ''CreateCart
```

### 2. The Decision Monad

The `Decision` type is a free monad that encapsulates the logic of accepting or rejecting a command. It provides a pure, testable way to express business rules.

#### 2.1 Decision Type Definition

```haskell
data Decision a where
  Return :: a -> Decision a
  Bind :: Decision a -> (a -> Decision b) -> Decision b
  GenUuid :: Decision Uuid
  Accept :: InsertionType -> Array a -> Decision a
  Reject :: Text -> Decision a
```

The `Decision` type is a GADT that supports:
- Monadic composition via `Return` and `Bind`
- UUID generation via `GenUuid`
- Terminal acceptance via `Accept`
- Terminal rejection via `Reject`

#### 2.2 Smart Constructors (Decision Module)

The `Decision` module (`core/service/Decision.hs`) provides user-friendly smart constructors:

| Function | Purpose | InsertionType |
|----------|---------|---------------|
| `generateUuid` | Generate a UUID within a Decision | N/A (intermediate) |
| `acceptNew events` | Accept only if entity doesn't exist | `StreamCreation` |
| `acceptExisting events` | Accept only if entity exists | `ExistingStream` |
| `acceptAfter pos events` | Accept with optimistic concurrency | `InsertAfter pos` |
| `acceptAny events` | Accept regardless of stream state | `AnyStreamState` |
| `reject reason` | Reject with a message | N/A |

#### 2.3 Decision Execution

The `runDecision` function interprets a `Decision` into a `Task`:

```haskell
runDecision :: DecisionContext -> Decision a -> Task Text (CommandResult a)
```

The `DecisionContext` provides effectful capabilities needed during interpretation:

```haskell
data DecisionContext = DecisionContext
  { genUuid :: Task Text Uuid
  }
```

`CommandResult` captures the outcome:

```haskell
data CommandResult event
  = AcceptCommand InsertionType (Array event)
  | RejectCommand Text
```

### 3. The Entity Abstraction

Entities represent the current state of a domain object, reconstructed from its event history.

#### 3.1 The Entity Typeclass

```haskell
class Entity entity where
  type EntityIdType entity :: Type
  type EntityIdType entity = Uuid  -- Default

  initialStateImpl :: entity
  updateImpl :: EventOf entity -> entity -> entity
```

Key functions:
- `initialStateImpl`: The starting state before any events are applied
- `updateImpl`: How to apply an event to evolve the entity state

#### 3.2 The Event Typeclass

```haskell
class Event event where
  getEventEntityIdImpl :: event -> EntityIdType (EntityOf event)
```

Events must provide a way to extract their entity ID, enabling routing to the correct stream.

#### 3.3 Example Entity Definition

```haskell
data CartEntity = CartEntity
  { cartId :: Uuid,
    items :: Array CartItem
  }

instance Entity CartEntity where
  initialStateImpl = CartEntity { cartId = Uuid.nil, items = Array.empty }
  updateImpl = update

update :: CartEvent -> CartEntity -> CartEntity
update event _ = case event of
  CartCreated {entityId} -> CartEntity { cartId = entityId, items = Array.empty }

type instance EventOf CartEntity = CartEvent
type instance NameOf CartEntity = "CartEntity"
```

### 4. The EntityFetcher

The `EntityFetcher` reconstructs an entity's current state by reading its event stream and applying the update function.

#### 4.1 EntityFetcher Interface

```haskell
data EntityFetcher state event = EntityFetcher
  { fetch :: EntityName -> StreamId -> Task Error (EntityFetchResult state)
  }

data EntityFetchResult state
  = EntityNotFound
  | EntityFound state
```

#### 4.2 Entity Reconstruction Process

The `EntityFetcher.new` function creates a fetcher that:

1. Reads all events from the stream
2. Folds over them with `reduceFunction` (the entity's `updateImpl`)
3. Returns `EntityNotFound` if no events exist, or `EntityFound finalState` otherwise

```haskell
new ::
  EventStore event ->
  state ->           -- Initial state
  (event -> state -> state) ->  -- Reduce function (updateImpl)
  Task Error (EntityFetcher state event)
```

### 5. The CommandHandler

The `CommandHandler` orchestrates command execution, connecting all the pieces together.

#### 5.1 CommandHandler Interface

```haskell
data CommandHandler event = CommandHandler
  { eventStore :: EventStore event,
    maxRetries :: Int,
    retryDelayMs :: Int
  }
```

#### 5.2 The Execute Function

```haskell
execute ::
  forall command commandEntity commandEvent.
  ( Command command, ... ) =>
  EventStore commandEvent ->
  EntityFetcher commandEntity commandEvent ->
  EntityName ->
  command ->
  Task Text CommandHandlerResult
```

The execute function performs the following steps:

1. **Extract Entity ID**: Call `getEntityIdImpl` to get the entity ID from the command
2. **Fetch Current State**: Use `EntityFetcher.fetch` to reconstruct the entity (or determine it doesn't exist)
3. **Run Decision Logic**: Execute `decideImpl` with the command and current entity state
4. **Handle Decision Outcome**:
   - If `RejectCommand`: Return `CommandRejected`
   - If `AcceptCommand`: Validate constraints and persist events
5. **Persist Events**: Insert events into the EventStore
6. **Handle Concurrency**: On conflict, retry with exponential backoff and jitter

#### 5.3 CommandHandlerResult

```haskell
data CommandHandlerResult
  = CommandAccepted
      { streamId :: StreamId,
        eventsAppended :: Int,
        retriesAttempted :: Int
      }
  | CommandRejected
      { reason :: Text
      }
  | CommandFailed
      { error :: Text,
        retriesAttempted :: Int
      }
```

This internal result type captures all details needed for debugging and monitoring.

### 6. CommandResponse (Client-Facing)

The `CommandResponse` type provides a simplified, client-facing view of command outcomes:

```haskell
data CommandResponse
  = Accepted { entityId :: Text }
  | Rejected { reason :: Text }
  | Failed { error :: Text }
```

The `fromHandlerResult` function converts internal results to client-facing responses, hiding internal details like retry counts.

### 7. Template Haskell Command Derivation

The `command` splice (`Service.CommandHandler.TH`) automates boilerplate generation:

```haskell
command ''CreateCart
```

This validates and generates:

1. **Validates** `getEntityId` function signature matches expected format
2. **Validates** `decide` function signature matches expected format
3. **Validates** `EntityOf` type instance exists
4. **Validates** `EntityIdType` (uses default `Uuid` if not specified)
5. **Generates** `Command` instance with `getEntityIdImpl` and `decideImpl`
6. **Generates** `type instance NameOf CreateCart = "CreateCart"`
7. **Generates** `KnownHash` instance for type-level hashing

#### 7.1 Multi-Tenancy Support

When `type MultiTenancy = True` is defined in the command module:
- `getEntityId` must accept `Uuid -> command -> Maybe id`
- `decide` must accept `Uuid -> command -> Maybe entity -> Decision event`

### 8. Service Registration

Commands are registered with a Service definition:

```haskell
service :: Service _ _ _ _
service =
  Service.new
    |> Service.command @AddItem
    |> Service.command @CreateCart
    |> Service.useServer WebApi.server
    |> Service.useEventStore postgresConfig
```

The `Service.command` function:
1. Records the command in a type-level row
2. Associates it with its API via `ApiOf`
3. Enables endpoint generation at service startup

### 9. Complete Command Flow

```
Command arrives (via API adapter)
    |
    v
getEntityIdImpl(command) -> Maybe EntityId
    |
    +-- Nothing: Entity creation (no fetch needed)
    |
    +-- Just entityId: Fetch existing entity
            |
            v
        EntityFetcher.fetch(entityName, streamId)
            |
            v
        Read all events from stream
            |
            v
        Fold with updateImpl -> EntityFetchResult
            |
            +-- EntityNotFound: entity = Nothing
            |
            +-- EntityFound state: entity = Just state
    |
    v
decideImpl(command, maybeEntity) -> Decision
    |
    v
runDecision(context, decision) -> CommandResult
    |
    +-- RejectCommand reason
    |       |
    |       v
    |   Return CommandRejected
    |
    +-- AcceptCommand insertionType events
            |
            v
        Validate insertion constraints
            |
            v
        EventStore.insert(payload)
            |
            +-- Success: Return CommandAccepted
            |
            +-- Conflict: Retry with backoff (up to maxRetries)
            |
            +-- Error: Return CommandFailed
```

## Consequences

### Positive

1. **Pure decision logic**: The `decide` function is pure, making business logic easy to test
2. **Explicit state requirements**: `InsertionType` makes concurrency constraints explicit
3. **Type-safe relationships**: Type families ensure commands, entities, and events align at compile time
4. **Automatic retry**: Optimistic concurrency conflicts are handled transparently
5. **Separation of concerns**: Decision logic is separate from persistence and transport

### Negative

1. **Multiple function signatures**: Commands require both `getEntityId` and `decide` functions
2. **TH magic**: The `command` splice hides significant validation and generation
3. **Type family spread**: Type instances are defined in command modules, not centrally
4. **Learning curve**: Understanding the full flow requires knowledge of multiple modules

### Trade-offs

1. **Explicit over implicit**: Type families make relationships explicit at the cost of verbosity
2. **Safety over convenience**: Compile-time validation catches errors early but requires more ceremony
3. **Purity over simplicity**: The Decision monad enables testing but adds conceptual overhead

### Future Considerations

1. Consider a unified command builder that combines `getEntityId`, `decide`, and type instances
2. Explore property-based testing utilities for Decision logic
3. Add support for aggregate-level invariants across multiple commands
4. Consider event versioning and upcasting support

## References

- `/Users/nick/Source/NeoHaskell/core/service/Service/Command/Core.hs` - Command typeclass and Decision type
- `/Users/nick/Source/NeoHaskell/core/service/Decision.hs` - Decision smart constructors
- `/Users/nick/Source/NeoHaskell/core/service/Service/CommandHandler/Core.hs` - Command execution
- `/Users/nick/Source/NeoHaskell/core/service/Service/CommandHandler/TH.hs` - Template Haskell generation
- `/Users/nick/Source/NeoHaskell/core/service/Service/CommandResponse.hs` - Client-facing response types
- `/Users/nick/Source/NeoHaskell/core/service/Service/EntityFetcher/Core.hs` - Entity reconstruction
- `/Users/nick/Source/NeoHaskell/core/service/Service/ServiceDefinition/Core.hs` - Service registration
- `/Users/nick/Source/NeoHaskell/testbed/src/Testbed/Cart/Commands/CreateCart.hs` - Example command
- `/Users/nick/Source/NeoHaskell/testbed/src/Testbed/Cart/Core.hs` - Example entity and events
- `/Users/nick/Source/NeoHaskell/docs/decisions/0001-initial-architecture-baseline.md` - Baseline ADR
- `/Users/nick/Source/NeoHaskell/docs/decisions/0002-webapi-adapter-architecture.md` - WebAPI ADR
