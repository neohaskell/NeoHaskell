# ADR-0007: Queries (Read Models)

## Status

Implemented

### Implementation status

- ✅ Core types (Query, QueryOf, QueryAction, EntitiesOf)
- ✅ QueryObjectStore trait + InMemory implementation
- ✅ QueryUpdater and QueryRegistry
- ✅ QuerySubscriber (event subscription, rebuild on startup)
- ✅ Template Haskell derivation (deriveQuery)
- ✅ HTTP endpoint (GET /queries/{name})
- ✅ Declarative Application API (withEventStore, withQuery, run)
- ⏳ Single instance endpoint (GET /queries/{name}/{id}) - see #239
- ⏳ Pagination support - see #240
- ⏳ Dynamic filtering - see #241

## Context

NeoHaskell implements Event Sourcing and CQRS as its core architectural pattern. Currently, the system supports:

- **Services** that contain commands and operate on single entities
- **EventStore** for persisting events (ADR-0004)
- **SnapshotCache** for caching entity state (ADR-0006)
- **EntityFetcher** for reconstructing entities from events

However, real-world applications frequently need to query data that spans multiple entities. Consider a dashboard showing "User Orders" that combines user profile data with their order history. Under pure event sourcing, this requires:

1. Fetching the User entity from its event stream
2. Fetching all Order entities for that user from their respective streams
3. Combining the data at read time

This approach has significant drawbacks:

- **Performance**: Multiple entity fetches per query, potentially replaying thousands of events
- **Complexity**: Business logic for combining entities scattered across application code
- **Latency**: Cannot pre-compute aggregations; every read is expensive

CQRS (Command Query Responsibility Segregation) solves this by separating the write model (event streams) from read models (projections/queries). Read models are denormalized views optimized for specific query patterns, updated asynchronously from the event stream.

### Requirements

1. **Multi-entity aggregation**: Combine data from multiple entity types into a single queryable structure
2. **Automatic updates**: Read models update automatically when relevant events occur
3. **HTTP exposure**: Auto-generated endpoints for querying read models
4. **Eventual consistency**: Acceptable for read models to lag slightly behind writes
5. **Type safety**: Compile-time verification of entity-to-query relationships
6. **Performance**: Query updates must not impact command processing latency

### Design Constraints

- Must integrate with existing EventStore subscription infrastructure
- Must work with the existing Service pattern
- Should follow established NeoHaskell patterns (traits, configuration classes)
- Should support multiple storage backends (in-memory for dev, persistent for production)

## Decision

We will implement a Queries feature providing read models that combine multiple entities into queryable types, automatically updated via event subscriptions.

### Core Types

#### QueryAction

Represents the outcome of combining an entity with a query:

```haskell
data QueryAction query
    = Update query   -- Store/update this query instance
    | Delete         -- Remove this query instance
    | NoOp           -- Take no action
```

#### Query Typeclass (Marker)

```haskell
class Query query
```

This marker class enables type-level constraints and is generated by Template Haskell.

#### QueryOf Typeclass

Defines how an entity contributes to a query:

```haskell
class (Entity entity, Query query) => QueryOf entity query where
    -- Extract the query instance ID from an entity
    queryId :: entity -> UUID

    -- Combine entity state with existing query state
    combine :: entity -> Maybe query -> QueryAction query
```

**Design rationale**:

- `queryId` extracts the identifier that groups entities into a single query instance. For `UserOrders`, both `User` and `Order` entities return the user's ID, so all orders for a user combine into one `UserOrders` instance.

- `combine` is the projection function. It receives the current entity state and optionally the existing query state, returning an action. This enables both creation (when `Nothing`) and updates (when `Just existingQuery`).

#### EntitiesOf Type Family

Maps a query type to its constituent entity types:

```haskell
type family EntitiesOf query :: [Type]
-- Generated by TH: type instance EntitiesOf UserOrders = '[User, Order]
```

This enables compile-time verification and runtime dispatch to the correct `QueryOf` instance.

### QueryObjectStore Trait

Persistent storage for query instances, following the EventStore/SnapshotCache trait pattern:

```haskell
data QueryObjectStore query = QueryObjectStore
    { get :: UUID -> Task Error (Maybe query),
      atomicUpdate :: UUID -> (Maybe query -> Maybe query) -> Task Error Unit,
      delete :: UUID -> Task Error Unit,
      getAll :: Task Error (Array query)
    }

data Error
    = StorageError Text
    | SerializationError Text
    deriving (Eq, Show)
```

**Key design choice**: `atomicUpdate` provides atomic read-modify-write semantics. This is critical for handling concurrent updates to the same query instance (e.g., two orders for the same user arriving simultaneously).

#### InMemory Implementation

```haskell
data InMemoryQueryObjectStoreConfig = InMemoryQueryObjectStoreConfig

instance QueryObjectStoreConfig InMemoryQueryObjectStoreConfig where
    createQueryObjectStore ::
        (Json.FromJSON query, Json.ToJSON query) =>
        InMemoryQueryObjectStoreConfig ->
        Task Text (QueryObjectStore query)
```

Implementation uses `ConcurrentVar (Map UUID query)` with `ConcurrentVar.modifyReturning` for atomic updates.

### User-Facing API

#### Query Type Definition

Users define a query as a regular Haskell record:

```haskell
data UserOrders = UserOrders
    { id :: UUID,
      userName :: Text,
      orders :: Array Order
    }
    deriving (Generic)

instance Json.FromJSON UserOrders
instance Json.ToJSON UserOrders
```

**Convention**: All query types must have an `id :: UUID` field.

#### QueryOf Instances

Users define how each entity contributes to the query:

```haskell
instance QueryOf User UserOrders where
    queryId user = user.id

    combine user mUserOrders = do
        let existingOrders = mUserOrders |> Maybe.map (.orders) |> Maybe.withDefault []
        Update UserOrders
            { id = user.id,
              userName = user.name,
              orders = existingOrders
            }

instance QueryOf Order UserOrders where
    queryId order = order.userId

    combine order mUserOrders = do
        case mUserOrders of
            Nothing -> NoOp  -- Wait for User to create the query first
            Just userOrders ->
                Update userOrders { orders = userOrders.orders |> Array.append order }
```

#### Template Haskell Derivation

```haskell
deriveQuery ''UserOrders ['User, 'Order]
```

Generates:

- `type instance NameOf UserOrders = "user-orders"`
- `type instance EntitiesOf UserOrders = '[User, Order]`
- `instance Query UserOrders`
- `KnownHash "UserOrders"`
- Runtime registry entries mapping entity names to query updater functions

### Application Layer

The Queries feature introduces an Application layer that combines multiple Services:

```haskell
app :: Application
app =
    Application.new
        |> Application.withService userService
        |> Application.withService orderService
        |> Application.withQuery @UserOrders
        |> Application.useEventStore postgresConfig
        |> Application.useSnapshotCache inMemoryConfig
        |> Application.useQueryObjectStore InMemoryQueryObjectStoreConfig
        |> Application.useServer webTransportServer
```

**Design rationale**: Configuration that was previously at Service level (EventStore, SnapshotCache) moves to Application level. This enables:

- Sharing a single EventStore across multiple Services
- Queries subscribing to events from any Service
- Centralized HTTP server configuration

Services become focused on their core concern:

```haskell
userService :: Service _ _
userService =
    Service.new
        |> Service.command @CreateUser
        |> Service.command @UpdateUser
```

### Query Update Architecture

#### Async Subscriber Pattern

Query updates happen asynchronously via EventStore subscriptions:

```
Command → EventStore.insert → [Event persisted] → Subscriber notified
                                                         ↓
                                            EntityFetcher.fetch entity
                                                         ↓
                                            QueryOf.combine entity query
                                                         ↓
                                            QueryObjectStore.atomicUpdate
```

**Why async (not synchronous in CommandExecutor)**:

1. **Consistency**: Events are committed before Query updates begin. If Query update fails, the event is still persisted (eventual consistency).

2. **Performance**: Zero latency impact on command processing. Commands return immediately after event persistence; Query updates proceed in parallel.

3. **Failure isolation**: A bug in Query logic cannot break command processing.

4. **Scalability**: Query subscribers can be scaled independently from command processors.

#### Update Flow Detail

1. Event arrives at subscriber with `entityName` and `streamId`
2. Subscriber consults runtime registry to find Queries affected by this `entityName`
3. For each affected Query:
   - Use `EntityFetcher` (with SnapshotCache) to reconstruct entity from `(entityName, streamId)`
   - Call `queryId entity` to determine which Query instance to update
   - Call `QueryObjectStore.atomicUpdate queryInstanceId transformer` where transformer:
     - Reads current `Maybe query` from store
     - Calls `combine entity maybeQuery`
     - Handles `QueryAction`: `Update` stores, `Delete` removes, `NoOp` skips

#### Concurrent Update Handling

`QueryObjectStore.atomicUpdate` ensures atomic read-modify-write:

```haskell
atomicUpdate :: UUID -> (Maybe query -> Maybe query) -> Task Error Unit
```

When two events for the same Query instance arrive simultaneously:

- Both call `atomicUpdate` with the same UUID
- The `ConcurrentVar` ensures operations are serialized
- Each update sees the result of the previous update
- No lost updates, no dirty reads

### Application Startup Sequence

1. Initialize EventStore connection
2. Initialize SnapshotCache
3. Initialize QueryObjectStore (starts empty)
4. **Rebuild all Queries from EventStore**:
   - Read all events in global position order
   - For each event, trigger Query update logic
   - Track final position N after full rebuild
5. Start Query subscriber from position N+1
6. Start HTTP server with Service endpoints + Query endpoints

**Design note**: Full rebuild on startup ensures consistency but may be slow for large event stores. Future work may add incremental rebuilds or checkpoint persistence.

### Auto-Generated HTTP Endpoints

Queries are exposed via auto-generated REST endpoints:

```
GET /queries/{query-name}
```

For `UserOrders` with `NameOf UserOrders = "user-orders"`:

```
GET /queries/user-orders
Response: [{"id": "...", "userName": "...", "orders": [...}}, ...]
```

Returns all instances of the Query as a JSON array.

**Future work**: Filtered queries (`GET /queries/user-orders/{id}`), pagination, field selection.

### Module Structure

```text
core/service/
  Service/
    Query.hs                    -- Re-export wrapper
    Query/
      Core.hs                   -- Query, QueryOf typeclasses, QueryAction
      QueryObjectStore.hs       -- QueryObjectStore trait
      QueryObjectStore/
        InMemory.hs             -- InMemory implementation
      TH.hs                     -- Template Haskell: deriveQuery
      Subscriber.hs             -- Event subscription and update logic
```

Follows established patterns: flat structure with one level for implementation variants.

## Consequences

### Positive

1. **CQRS compliance**: Clean separation between write models (Services/EventStore) and read models (Queries).

2. **Multi-entity aggregation**: Users can define read models spanning any number of entity types with type-safe compile-time verification.

3. **Zero command latency impact**: Async subscriber pattern means command processing is unaffected by Query complexity.

4. **Automatic HTTP exposure**: Queries are immediately queryable via auto-generated endpoints, reducing boilerplate.

5. **Type safety**: `QueryOf` instances are checked at compile time. The `EntitiesOf` type family enables the TH to verify all referenced entities exist.

6. **Atomic updates**: `atomicUpdate` in QueryObjectStore prevents race conditions when multiple events affect the same Query instance.

7. **Consistent patterns**: Follows established NeoHaskell patterns (traits, configuration classes, TH derivation) making the feature familiar to existing users.

8. **Backend flexibility**: QueryObjectStore trait allows swapping implementations (InMemory for dev, Postgres/Redis for production).

### Negative

1. **Eventual consistency**: Queries lag behind events by milliseconds. Applications requiring strong consistency must read from the EventStore directly.

2. **Full rebuild on startup**: Processing all events on every application restart may be slow for large event stores. Mitigation: future work on checkpoint persistence and incremental rebuilds.

3. **Increased complexity**: Users must understand the distinction between commands (synchronous, strongly consistent) and queries (async, eventually consistent).

4. **Application layer coupling**: Services now depend on being combined into an Application to access shared EventStore and enable Query subscriptions.

5. **Runtime registry**: TH-generated runtime registry adds a layer of indirection for entity-to-query dispatch that may complicate debugging.

6. **Query identity convention**: Requiring `id :: UUID` field on all Query types is a convention that cannot be enforced at compile time (only at runtime).

### EventStore Layering Decision

This section documents the resolution of the EventStore typing problem when multiple Services share a single EventStore.

#### Problem

The EventStore is currently typed by a single `eventType`. With multiple Services (each with different event types) in one Application, we needed to decide how to handle serialization and cross-service event routing.

#### Decision: Cast Function Approach

**No new types needed.** Instead:

1. **Implementations create `EventStore Json.Value`**: Both Postgres and InMemory create an `EventStore Json.Value`. Postgres already stores JSON internally, so minimal change. InMemory stores `Event Json.Value` instead of `Event eventType`.

2. **Add a `castEventStore` function** that converts `EventStore Json.Value` to `EventStore eventType`:

```haskell
castEventStore ::
  (Json.ToJSON eventType, Json.FromJSON eventType) =>
  EventStore Json.Value ->
  EventStore eventType
```

This function:
- Wraps `insert` to encode the payload to JSON before inserting
- Wraps read functions to decode JSON events to the typed event
- Wraps subscription handlers to decode before calling the handler

3. **Services use `castEventStore`** to get a typed `EventStore eventType`

4. **Query subscribers use `EventStore Json.Value` directly** with `EntityName`-based routing and their own deserialization

#### Rationale

1. **No new types**: Reuses existing `Event`, `InsertionPayload`, and `EventStore` types
2. **Service isolation**: Services don't know about each other's event types
3. **Type safety**: Full compile-time safety within services; runtime boundary only at cross-service concerns (Query subscribers)
4. **Minimal implementation changes**: Postgres implementation barely changes (already stores JSON); InMemory just changes what it stores internally
5. **Sharding-ready**: JSON store can be sharded by `EntityName`
6. **Independent deployability**: Services can evolve event schemas without coordination

#### How it Works with Queries

1. Application creates an `EventStore Json.Value` (Postgres or InMemory)
2. Each Service calls `castEventStore` to get a typed `EventStore eventType`
3. Query subscribers subscribe to the `EventStore Json.Value` directly
4. Query subscribers use `EntityName` field from events to route to appropriate handlers
5. Each Query handler deserializes the JSON event to reconstruct the entity

#### Migration from Current Implementation

1. Change `PostgresEventStore` and `InMemoryEventStore` to produce `EventStore Json.Value` (Postgres already stores JSON internally; InMemory changes from storing typed events to storing `Event Json.Value`)
2. Add `EventStore.castEventStore` function that wraps insert/read/subscribe with JSON encoding/decoding
3. Services continue using `EventStore eventType` API by calling `castEventStore` (minimal change to service code)

### Related Work

1. **EntityFetcher simplification**: Remove `EntityFetcher.new`, rename `EntityFetcher.newWithCache` to `EntityFetcher.new`. Cache-aware fetching becomes the default.

2. **Query filtering endpoints**: Add `GET /queries/{name}/{id}` for single-instance queries.

3. **Pagination**: Add offset/limit support for `getAll` queries.

4. **Checkpoint persistence**: Persist last-processed event position to avoid full rebuilds.

5. **Query versioning**: Support schema evolution for Query types.

## References

- [ADR-0004: EventStore Abstraction](0004-eventstore-abstraction.md) - Foundation for event persistence and subscriptions
- [ADR-0006: Entity Snapshot Cache](0006-entity-snapshot-cache.md) - Caching pattern reused by Query updates
- CQRS pattern: https://martinfowler.com/bliki/CQRS.html
- Event Sourcing and Read Models: https://www.eventstore.com/blog/what-is-event-sourcing
