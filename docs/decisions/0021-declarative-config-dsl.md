# ADR-0021: Declarative Config DSL

## Status

Proposed

## Context

NeoHaskell applications require configuration from multiple sources: environment variables, CLI arguments, configuration files, and hardcoded defaults. Currently, configuration lookup happens lazily during request processing, leading to poor failure modes.

### Current Behavior

When a required environment variable like `OPENROUTER_API_KEY` is missing, the error surfaces deep in the integration layer during request handling:

```
Executing StartMetricEvaluation on port 8080
[Dispatcher] Error processing event: AuthenticationError "Missing environment variable: OPENROUTER_API_KEY"
```

The application starts successfully, accepts requests, and then fails when the missing config is first accessed. This creates several problems:

1. **Late failure**: The app appears healthy in orchestration systems (Kubernetes, Docker Compose) because it starts without error
2. **Partial processing**: Requests may be partially processed before failing, leaving inconsistent state
3. **Poor observability**: Errors appear as integration/auth failures rather than configuration problems
4. **Difficult debugging**: Missing config is discovered at usage site, not declaration site

### Design Goals

1. **Fail-fast**: All required configuration should be validated at startup, before the application accepts requests
2. **Type-safe**: Configuration values should be statically typed, not stringly-typed lookups
3. **Self-documenting**: Config schema should be visible in code, with descriptions for each field
4. **DRY**: Config fields should be declared once, with type, source, default, and documentation together
5. **Testable**: Config can be overridden in tests without environment manipulation
6. **Composable**: Configs can be nested and combined (app config includes service configs)
7. **Zero-boilerplate access**: Using config in application code should require no ceremony

### Current Patterns in Codebase

Environment variables are currently accessed via `Environment.require` at point of use:

```haskell
-- In Integration.OpenRouter
apiKey <- Environment.require "OPENROUTER_API_KEY"
```

This is convenient but fails the design goals above.

## Decision

We will introduce a `defineConfig` Template Haskell macro that generates type-safe configuration with fail-fast validation at startup.

### 1. defineConfig DSL

The `defineConfig` macro defines a configuration schema declaratively:

```haskell
{-# LANGUAGE TemplateHaskell #-}
module MyApp.Config where

import Config (defineConfig)
import Config qualified

defineConfig "AppConfig"
  [ Config.field @Int "port"
      |> Config.doc "HTTP port to listen on"
      |> Config.defaultsTo 8080
      |> Config.envVar "PORT"
      |> Config.cliLong "port"
      |> Config.cliShort 'p'

  , Config.field @Text "databaseUrl"
      |> Config.doc "PostgreSQL connection string"
      |> Config.required
      |> Config.envVar "DATABASE_URL"

  , Config.field @(Secret Text) "openRouterKey"
      |> Config.doc "OpenRouter API key for LLM integration"
      |> Config.secret
      |> Config.required
      |> Config.envVar "OPENROUTER_API_KEY"

  , Config.field @LogLevel "logLevel"
      |> Config.doc "Minimum log level (debug, info, warn, error)"
      |> Config.defaultsTo Info
      |> Config.envVar "LOG_LEVEL"

  , Config.field @(Array Text) "features"
      |> Config.doc "Enabled feature flags"
      |> Config.defaultsTo []
      |> Config.envVar "FEATURES"
  ]
```

### 2. What TH Generates

The `defineConfig` macro generates:

**Data type:**
```haskell
data AppConfig = AppConfig
  { port :: Int
  , databaseUrl :: Text
  , openRouterKey :: Secret Text
  , logLevel :: LogLevel
  , features :: Array Text
  }
  deriving (Generic)
```

**Default instance:**
```haskell
instance Default AppConfig where
  def = AppConfig
    { port = 8080
    , databaseUrl = error "Required field: databaseUrl"
    , openRouterKey = Secret.empty
    , logLevel = Info
    , features = []
    }
```

**JSON instances (for file-based config):**
```haskell
instance FromJSON AppConfig
instance ToJSON AppConfig  -- For config export/debugging
```

**Config parser (internal - generated by TH, users don't write this):**
```haskell
-- This is what TH generates internally using opt-env-conf.
-- Users never see or write this code - it's an implementation detail.
appConfigParser :: OptEnvConf.Parser AppConfig
```

**HasConfig constraint:**
```haskell
type HasAppConfig = (?config :: AppConfig)
```

### 3. Nested Configs

Configs can be composed using `Config.envPrefix` for namespace isolation:

```haskell
defineConfig "DatabaseConfig"
  [ Config.field @Text "host"
      |> Config.doc "Database host"
      |> Config.defaultsTo "localhost"

  , Config.field @Int "port"
      |> Config.doc "Database port"
      |> Config.defaultsTo 5432

  , Config.field @Text "name"
      |> Config.doc "Database name"
      |> Config.required
  ]

defineConfig "AppConfig"
  [ Config.nested @DatabaseConfig "database"
      |> Config.doc "Database connection settings"
      |> Config.envPrefix "DB_"

  , Config.nested @DatabaseConfig "redis"
      |> Config.doc "Redis connection settings"
      |> Config.envPrefix "REDIS_"
  ]
```

With `envPrefix "DB_"`, the nested fields become:
- `DB_HOST` (defaults to "localhost")
- `DB_PORT` (defaults to 5432)
- `DB_NAME` (required)

### 4. Application Integration

The `withConfig` function loads and validates configuration at startup:

```haskell
module Main where

import Application qualified
import MyApp.Config (AppConfig)

main :: IO ()
main = do
  app <- Application.new
    |> Application.withConfig @AppConfig
    |> Application.withService userService
    |> Application.withService orderService
  Application.run app
```

**Startup behavior:**

1. `withConfig` parses CLI args, env vars, and config files
2. All `required` fields are validated
3. Type conversions are checked (e.g., `PORT=abc` fails)
4. If any validation fails, the application exits with a clear error listing ALL missing/invalid config
5. If validation passes, the config is stored and available via `?config`

**Startup failure example:**
```
Configuration errors:

  DATABASE_URL: Required but not set
    Help: PostgreSQL connection string
    Sources: Environment variable DATABASE_URL

  OPENROUTER_API_KEY: Required but not set
    Help: OpenRouter API key for LLM integration
    Sources: Environment variable OPENROUTER_API_KEY

  PORT: Invalid value "abc" - expected Int
    Help: HTTP port to listen on
    Sources: Environment variable PORT, CLI --port/-p
    Default: 8080
```

### 5. Config Access via HasConfig

The `HasConfig` constraint provides zero-boilerplate access via implicit parameters:

```haskell
-- In any function with HasAppConfig constraint
sendToOpenRouter :: (HasAppConfig) => Request -> Task Error Response
sendToOpenRouter request = do
  let apiKey = ?config.openRouterKey  -- Direct field access
  Http.post "https://openrouter.ai/api/v1/chat/completions"
    |> Http.bearer (Secret.unwrap apiKey)
    |> Http.jsonBody request
    |> Http.send
```

**Constraint propagation:**

```haskell
-- Constraint flows through call chain
handleRequest :: (HasAppConfig) => HttpRequest -> Task Error HttpResponse
handleRequest req = do
  result <- processWithLLM req.body  -- Calls sendToOpenRouter internally
  Http.respond 200 result

processWithLLM :: (HasAppConfig) => Text -> Task Error Text
processWithLLM prompt = do
  response <- sendToOpenRouter (makeRequest prompt)
  Task.yield response.content
```

### 6. Config Sources (Precedence)

Configuration values are resolved in this order (highest precedence first):

1. **CLI arguments**: `--port 3000`
2. **Environment variables**: `PORT=3000`
3. **Config file**: `config.yaml`, `config.json`
4. **Defaults**: As specified in `defaultsTo`

This follows the principle of least surprise and matches common tooling expectations.

### 7. Field Modifiers

| Modifier | Purpose | Example |
|----------|---------|---------|
| `Config.doc` | Human-readable description (shown in --help and errors) | `Config.doc "Database connection string"` |
| `Config.defaultsTo` | Default value if not provided | `Config.defaultsTo 8080` |
| `Config.required` | Must be provided (mutually exclusive with defaultsTo) | `Config.required` |
| `Config.secret` | Value is sensitive, redacted in logs/--help output | `Config.secret` |
| `Config.envVar` | Environment variable name | `Config.envVar "DATABASE_URL"` |
| `Config.envPrefix` | Prefix for nested config env vars | `Config.envPrefix "DB_"` |
| `Config.cliLong` | Long CLI flag name | `Config.cliLong "port"` |
| `Config.cliShort` | Short CLI flag character | `Config.cliShort 'p'` |

### 8. Type Support

**Primitive types (use `Config.field @Type`):**
- `Int`, `Integer` - Numeric values
- `Text`, `String` - Text values
- `Bool` - Boolean (accepts `true`/`false`, `1`/`0`, `yes`/`no`)
- `Double`, `Float` - Floating point

**Special types:**
- `Secret Text` - Sensitive value, redacted in Show/logs (see ADR-0016)
- `Array a` - List of values (comma-separated in env vars: `FEATURES=a,b,c`)
- `Maybe a` - Optional value (absence is valid, different from required)

**Custom types:**
- Enums with `FromJSON`/`Read` instances - use `Config.enum @MyEnum`
- Nested configs via other `defineConfig` types - use `Config.nested @OtherConfig`

```haskell
-- Enum example
data LogLevel = Debug | Info | Warn | Error
  deriving (Show, Read, Generic, FromJSON, ToJSON)

defineConfig "AppConfig"
  [ Config.enum @LogLevel "logLevel"
      |> Config.doc "Minimum log level"
      |> Config.defaultsTo Info
  ]
```

### 9. Env Var Naming Convention

When `envVar` is not explicitly specified, field names are converted to SCREAMING_SNAKE_CASE:

| Field Name | Generated Env Var |
|------------|-------------------|
| `port` | `PORT` |
| `databaseUrl` | `DATABASE_URL` |
| `openRouterKey` | `OPEN_ROUTER_KEY` |
| `enableFeatureX` | `ENABLE_FEATURE_X` |

Explicit `envVar` overrides this convention when needed.

### 10. TH Compile-Time Validation

The `defineConfig` macro performs validation at compile time:

**Missing documentation:**
```haskell
defineConfig "Config"
  [ Config.field @Int "port"
      |> Config.defaultsTo 8080
      -- Missing: |> Config.doc "..."
  ]
-- Compile error: Field 'port' missing required 'Config.doc' modifier
```

**Missing default or required:**
```haskell
defineConfig "Config"
  [ Config.field @Int "port"
      |> Config.doc "HTTP port"
      -- Neither defaultsTo nor required specified
  ]
-- Compile error: Field 'port' must have either 'Config.defaultsTo' or 'Config.required'
```

**Both default and required:**
```haskell
defineConfig "Config"
  [ Config.field @Int "port"
      |> Config.doc "HTTP port"
      |> Config.defaultsTo 8080
      |> Config.required
  ]
-- Compile error: Field 'port' cannot have both 'Config.defaultsTo' and 'Config.required'
```

### 11. Testing Support

Configs can be overridden in tests without environment manipulation:

```haskell
testWithConfig :: AppConfig -> (HasAppConfig => Task Error a) -> Task Error a
testWithConfig config action = let ?config = config in action

spec :: Spec
spec = describe "OpenRouter integration" do
  it "sends requests with API key" do
    let testConfig = def { openRouterKey = Secret.wrap "test-key" }
    result <- testWithConfig testConfig do
      sendToOpenRouter testRequest
    result.headers `shouldContain` ("Authorization", "Bearer test-key")
```

## Consequences

### Positive

1. **Fail-fast at startup**: All configuration is validated before the application accepts requests. Missing `OPENROUTER_API_KEY` is caught immediately, not during the first LLM request.

2. **Self-documenting**: The `defineConfig` block serves as documentation. `--help` output is automatically generated with descriptions.

3. **Type-safe**: Configuration values are statically typed. No `Text -> Int` conversion errors at runtime.

4. **DRY**: Each config field is declared once with its type, source, default, and documentation together.

5. **Testable**: The `HasConfig` constraint enables easy config injection in tests without environment variable manipulation.

6. **Secure by default**: The `Secret` type integrates with ADR-0016's `Redacted` type to prevent sensitive values from appearing in logs.

7. **Composable**: Nested configs with `envPrefix` enable clean separation of concerns (database config, cache config, etc.).

8. **Zero boilerplate access**: `?config.fieldName` syntax requires no ceremony at usage sites.

9. **Helpful error messages**: Startup failures list ALL missing/invalid config at once, with descriptions and valid sources.

### Negative

1. **Template Haskell complexity**: TH increases compile time and can produce cryptic error messages when something goes wrong in the macro.

2. **New dependency**: Wraps opt-env-conf library, adding a dependency to the core framework.

3. **Learning curve**: Developers must learn the DSL syntax and modifier system.

4. **IDE support**: Some IDEs have limited support for TH-generated code (autocomplete, go-to-definition).

### Trade-offs

1. **Explicit boilerplate vs TH magic**: We chose TH to eliminate boilerplate, accepting the complexity cost. The alternative (manual record + parser) would be more transparent but require ~5x more code per config field.

2. **Implicit parameters vs explicit passing**: We chose implicit parameters (`?config`) for ergonomics. The alternative (explicit `config` parameter everywhere) would be more explicit but add significant ceremony.

3. **Compile-time validation vs runtime flexibility**: We validate config schema at compile time. This catches errors early but means config schema changes require recompilation.

### Migration Path

**For existing applications:**

1. Define config type with `defineConfig`
2. Add `Application.withConfig @YourConfig` to application setup
3. Replace `Environment.require "VAR"` calls with `?config.fieldName`
4. Run application - any missing config will fail at startup with helpful message

**Example migration:**

Before:
```haskell
-- In Integration.OpenRouter
sendRequest request = do
  apiKey <- Environment.require "OPENROUTER_API_KEY"
  maybeBaseUrl <- Environment.get "OPENROUTER_BASE_URL"
  let baseUrl = maybeBaseUrl |> Maybe.withDefault "https://openrouter.ai"
  Http.post [fmt|{baseUrl}/api/v1/chat/completions|]
    |> Http.bearer apiKey
    |> Http.jsonBody request
    |> Http.send
```

After:
```haskell
-- In MyApp.Config
defineConfig "OpenRouterConfig"
  [ Config.field @(Secret Text) "apiKey"
      |> Config.doc "OpenRouter API key"
      |> Config.secret
      |> Config.required
      |> Config.envVar "OPENROUTER_API_KEY"

  , Config.field @Text "baseUrl"
      |> Config.doc "OpenRouter API base URL"
      |> Config.defaultsTo "https://openrouter.ai"
      |> Config.envVar "OPENROUTER_BASE_URL"
  ]

-- In Integration.OpenRouter
sendRequest :: (HasOpenRouterConfig) => Request -> Task Error Response
sendRequest request = do
  Http.post [fmt|{?config.baseUrl}/api/v1/chat/completions|]
    |> Http.bearer (Secret.unwrap ?config.apiKey)
    |> Http.jsonBody request
    |> Http.send
```

## References

- [Issue #364](https://github.com/neohaskell/neohaskell/issues/364) - Configuration validation should fail fast at startup
- [opt-env-conf](https://github.com/NorfairKing/opt-env-conf) - Underlying library for parsing CLI/env/file config
- [IHP Config](https://ihp.digitallyinduced.com/Guide/config.html) - Inspiration for HasConfig pattern
- [ADR-0016: Redacted Type for Sensitive Data](0016-redacted-type-for-sensitive-data.md) - Secret type integration
- [ADR-0008: Integration Pattern](0008-integration-pattern.md) - Context for where config is currently accessed
