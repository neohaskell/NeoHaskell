# ADR-0028: Internal Logging for Event-Sourced Observability

## Status

Proposed

## Context

NeoHaskell services deployed to fly.io are failing silently. Standard fly.io logs are insufficient for debugging framework-level operations. The framework needs internal visibility into request lifecycle, command processing, event application, and error paths.

### The Problem

When deploying NeoHaskell applications to fly.io, developers encounter silent failures with no visibility into:

- Request routing and lifecycle
- Command processing (received, executed, failed)
- Event application to entities
- Database and event store operations
- Framework-level errors

Standard fly.io logs capture stdout/stderr but provide no insight into the framework's internal state. This makes debugging deployed applications extremely difficult.

### Use Cases

1. **Debug silent failures on deployed dev servers**: See what the framework is doing when requests fail
2. **Request lifecycle visibility**: Track incoming requests, routing decisions, and responses
3. **Command processing monitoring**: Observe command reception, execution, and failures
4. **Event application tracking**: See when events are applied to entities
5. **Database operation observability**: Monitor event store and database interactions
6. **Foundation for future tooling**: Enable CLI/GUI observability tools (NeoQL integration)

### Requirements

1. **Use existing event store**: No new infrastructure—logs are events stored in the same event store
2. **No authentication for MVP**: Dev server only, authentication added in Phase 2
3. **Minimal footprint**: Internal framework feature, not exposed to users
4. **Backwards compatible**: Event structure can gain fields later without breaking changes
5. **HTTP endpoint for querying**: Simple GET endpoint to retrieve logs

### Scope

This ADR covers **Phase 1: MVP for dev server debugging**. Future phases will add:

- Phase 2: Authentication and authorization
- Phase 3: Log level filtering and retention policies
- Phase 4: NeoQL integration for advanced querying
- Phase 5: CLI/GUI observability tools

## Decision

### 1. Event Definition

Logs are immutable events stored in the event store:

```haskell
-- Event (immutable fact, past tense)
data LogRecorded = LogRecorded
  { logId     :: Uuid
  , timestamp :: DateTime
  , level     :: LogLevel
  , message   :: Text
  }
  deriving (Show, Eq, Generic)

data LogLevel = Debug | Info | Warn | Error
  deriving (Show, Eq, Generic, Ord)
```

**Design rationale:**

- **Immutable**: Events are facts that cannot be changed
- **Past tense**: `LogRecorded` follows event-sourcing naming conventions
- **Minimal fields**: MVP includes only essential data (id, timestamp, level, message)
- **Extensible**: Future phases can add `correlationId`, `requestId`, `component`, `metadata` without breaking changes

### 2. Internal Command

Framework-only command for recording logs (not exposed to users):

```haskell
-- Internal command (framework-only, not user-facing)
data RecordLog = RecordLog
  { level   :: LogLevel
  , message :: Text
  }
```

**Design rationale:**

- **Internal only**: Not part of the public API—framework uses this internally
- **Simple**: No ID or timestamp—generated by the framework when the command is processed
- **Command pattern**: Follows NeoHaskell's command/event architecture

### 3. Logging API

Framework internals use these functions to record logs:

```haskell
-- Logging API (framework internals only)
logDebug :: EventStore Json.Value -> Text -> Task _ Unit
logInfo  :: EventStore Json.Value -> Text -> Task _ Unit
logWarn  :: EventStore Json.Value -> Text -> Task _ Unit
logError :: EventStore Json.Value -> Text -> Task _ Unit
```

**Design rationale:**

- **Qualified imports**: `Log.debug`, `Log.info`, `Log.warn`, `Log.error` in framework code
- **EventStore parameter**: Logs are stored in the same event store as domain events
- **Task-based**: Follows NeoHaskell's `Task` pattern for effects
- **Level-specific functions**: Clearer than `log level message`

### 4. HTTP Endpoint

Simple GET endpoint for retrieving logs:

```http
GET /internal/logs?limit=100&since=2026-02-11T00:00:00Z

Response:
{
  "logs": [
    {
      "logId": "550e8400-e29b-41d4-a716-446655440000",
      "timestamp": "2026-02-12T10:30:00Z",
      "level": "Info",
      "message": "Request received: GET /api/cart/123"
    }
  ],
  "count": 1
}
```

**Query parameters:**

- `limit` (optional): Maximum number of logs to return (default: 100, max: 1000)
- `since` (optional): ISO 8601 timestamp—return logs after this time

**Design rationale:**

- **Simple GET**: No complex query language in MVP
- **Pagination**: `limit` parameter prevents overwhelming responses
- **Time filtering**: `since` parameter for incremental log retrieval
- **JSON response**: Standard format for HTTP APIs

### 5. Module Structure

```text
core/service/Service/Internal/
  Log/
    Events.hs   -- LogRecorded, LogLevel
    Entity.hs   -- InternalLog entity (if needed)
    API.hs      -- logDebug/Info/Warn/Error
  Routes.hs     -- /internal/logs handler
```

**Design rationale:**

- **`Service.Internal` namespace**: Clearly marks this as framework-internal
- **Separate modules**: Events, entity, API, and routes are separated for clarity
- **Follows existing patterns**: Mirrors structure of `Service.EventStore`, `Service.Command`

### 6. Implementation Details

**Logging functions:**

```haskell
-- Service/Internal/Log/API.hs
logDebug :: EventStore Json.Value -> Text -> Task _ Unit
logDebug store message = do
  logId <- Uuid.generate
  timestamp <- DateTime.now
  let event = LogRecorded { logId, timestamp, level = Debug, message }
  EventStore.append store "internal-logs" (Json.toJSON event)
    |> Task.mapError (\_ -> ())

logInfo :: EventStore Json.Value -> Text -> Task _ Unit
logInfo store message = do
  logId <- Uuid.generate
  timestamp <- DateTime.now
  let event = LogRecorded { logId, timestamp, level = Info, message }
  EventStore.append store "internal-logs" (Json.toJSON event)
    |> Task.mapError (\_ -> ())

-- logWarn and logError follow the same pattern
```

**HTTP endpoint handler:**

```haskell
-- Service/Internal/Routes.hs
handleInternalLogs :: EventStore Json.Value -> Wai.Request -> Task _ Wai.Response
handleInternalLogs store request = do
  let queryParams = Wai.queryString request
  let limit = parseLimit queryParams |> Maybe.withDefault 100
  let since = parseSince queryParams
  
  events <- EventStore.readStream store "internal-logs"
    |> Task.map (filterSince since)
    |> Task.map (Array.take limit)
  
  let response = Json.object
        [ ("logs", Json.toJSON events)
        , ("count", Json.toJSON (Array.length events))
        ]
  
  Wai.responseLBS HTTP.status200 
    [(HTTP.hContentType, "application/json")] 
    (Json.encode response)
    |> Task.yield
```

### 7. Security Considerations

**MVP (Phase 1):**

- **No authentication**: Endpoint is publicly accessible
- **Dev server only**: Not intended for production use
- **Minimal information disclosure**: Logs contain only framework operations, not sensitive data

**Future (Phase 2):**

- Add authentication middleware to `/internal/*` routes
- Require admin role for log access
- Add rate limiting to prevent abuse

### 8. Performance Considerations

**Event store volume:**

- Logs are stored as events in the same event store as domain events
- High-volume logging could impact event store performance
- **Mitigation**: Phase 3 will add log level filtering and retention policies

**Query performance:**

- Reading entire `internal-logs` stream could be slow for large log volumes
- **Mitigation**: Phase 4 will add NeoQL integration for efficient querying

**Logging overhead:**

- Each log call appends an event to the event store
- Minimal overhead for Info/Warn/Error levels
- Debug level should be used sparingly

## Consequences

### Positive

1. **Immediate visibility**: Framework operations are now observable on deployed dev servers
2. **No new infrastructure**: Uses existing event store—no additional services required
3. **Event-sourced logs**: Logs are immutable events with full history
4. **Naturally extensible**: Event structure can gain fields later (correlationId, requestId, component, metadata)
5. **Foundation for tooling**: Enables future CLI/GUI observability tools and NeoQL integration
6. **Follows framework patterns**: Uses command/event architecture consistently

### Negative

1. **Increases event store volume**: Every log is an event—high-volume logging could impact performance
2. **No authentication in MVP**: Logs are publicly accessible on dev servers (acceptable for dev-only use)
3. **Limited querying**: MVP only supports `limit` and `since` parameters—no advanced filtering
4. **No log rotation**: Logs accumulate indefinitely until retention policy is added in Phase 3

### Risks

| Risk | Mitigation |
|------|------------|
| Log volume impacts event store performance | Phase 3 adds log level filtering and retention policies |
| No authentication means logs are publicly accessible | MVP is dev-only; Phase 2 adds authentication |
| Limited querying makes finding specific logs difficult | Phase 4 adds NeoQL integration for advanced querying |
| Debug-level logging could overwhelm event store | Framework uses Info/Warn/Error by default; Debug is opt-in |

## Alternatives Considered

### Alternative 1: Separate logging infrastructure (e.g., Loki, Elasticsearch)

**Approach**: Use a dedicated logging service instead of the event store.

**Rejected because**:

- Adds new infrastructure dependencies
- Increases deployment complexity
- Requires additional configuration and maintenance
- Event store already provides persistence and querying

### Alternative 2: Stdout/stderr logging only

**Approach**: Use standard output for logs and rely on fly.io's log aggregation.

**Rejected because**:

- No structured querying (grep-only)
- Logs are ephemeral (lost on container restart)
- No correlation with domain events
- Difficult to build tooling on top of unstructured logs

### Alternative 3: Expose logs via WebSocket

**Approach**: Stream logs in real-time via WebSocket connection.

**Rejected for MVP because**:

- Adds complexity (WebSocket handling, connection management)
- Not needed for dev server debugging (polling is sufficient)
- Can be added in Phase 5 for real-time observability tools

## Implementation Plan

### Phase 1: MVP (This ADR)

- [ ] Define `LogRecorded` event and `LogLevel` type
- [ ] Implement `RecordLog` command
- [ ] Create `logDebug`, `logInfo`, `logWarn`, `logError` functions
- [ ] Add `/internal/logs` HTTP endpoint
- [ ] Integrate logging into framework internals (request handling, command processing)
- [ ] Write unit tests for logging API
- [ ] Write integration tests for HTTP endpoint

### Phase 2: Authentication (Future ADR)

- Add authentication middleware to `/internal/*` routes
- Require admin role for log access
- Add rate limiting

### Phase 3: Filtering and Retention (Future ADR)

- Add log level filtering (query parameter: `level=Info`)
- Add retention policy (auto-delete logs older than N days)
- Add log volume monitoring

### Phase 4: NeoQL Integration (Future ADR)

- Add NeoQL support for advanced log querying
- Enable filtering by component, correlationId, requestId
- Add aggregation queries (count by level, errors per hour)

### Phase 5: Observability Tools (Future ADR)

- CLI tool for tailing logs (`neo logs tail`)
- GUI dashboard for log visualization
- Real-time log streaming via WebSocket

## References

- [ADR-0004: EventStore Abstraction](0004-eventstore-abstraction.md) — Event store patterns
- [ADR-0003: Command Abstraction and Flow](0003-command-abstraction-and-flow.md) — Command patterns
- GitHub Issue #XXX — Internal logging for observability (to be created)
