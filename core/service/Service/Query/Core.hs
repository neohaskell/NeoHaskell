{-# LANGUAGE AllowAmbiguousTypes #-}

module Service.Query.Core (
  -- * Query Action
  QueryAction (..),

  -- * Query Typeclass
  Query,

  -- * Query Composition
  QueryOf (..),

  -- * Type Families
  EntitiesOf,
  FirstEntityOf,
) where

import Basics
import Maybe (Maybe)
import Service.Entity.Core (Entity)
import Uuid (Uuid)


-- | Represents the outcome of combining an entity state with a query.
--
-- When an entity changes, we call 'combine' to determine what should happen
-- to the corresponding query instance:
--
-- * 'Update': Store or update the query instance with new data
-- * 'Delete': Remove the query instance from the store
-- * 'NoOp': Take no action (query instance remains unchanged)
--
-- Example:
--
-- @
-- combine user maybeExistingQuery =
--   case user.status of
--     Active -> Update (UserOrders { userId = user.id, orderCount = ... })
--     Deleted -> Delete
--     _ -> NoOp
-- @
data QueryAction query
  = Update query -- ^ Store or update this query instance
  | Delete -- ^ Remove this query instance from the store
  | NoOp -- ^ Take no action
  deriving (Eq, Show, Generic)


-- | Marker typeclass for query types.
--
-- This typeclass is used to identify types that represent read models (queries).
-- It is typically derived automatically via Template Haskell using 'deriveQuery'.
--
-- Example:
--
-- @
-- data UserOrders = UserOrders
--   { userId :: Uuid
--   , userName :: Text
--   , orders :: Array Order
--   }
--
-- -- Generated by: deriveQuery ''UserOrders ['User, 'Order]
-- instance Query UserOrders
-- @
class Query query


-- | Defines how an entity contributes to a query (read model).
--
-- Each entity that participates in a query must implement this typeclass,
-- specifying:
--
-- * 'queryId': Extract the query instance ID from an entity. For a UserOrders
--   query, both User and Order entities return the user's ID.
--
-- * 'combine': Merge the entity state with the existing query state (if any)
--   to produce a QueryAction indicating what should happen to the query.
--
-- Example:
--
-- @
-- instance QueryOf User UserOrders where
--   queryId user = user.id
--   combine user maybeExisting = Update UserOrders
--     { userId = user.id
--     , userName = user.name
--     , orders = maybeExisting |> Maybe.map (.orders) |> Maybe.withDefault Array.empty
--     }
--
-- instance QueryOf Order UserOrders where
--   queryId order = order.userId
--   combine order maybeExisting = case maybeExisting of
--     Just existing -> Update existing { orders = existing.orders |> Array.append order }
--     Nothing -> NoOp  -- Can't add order to non-existent user query
-- @
class (Entity entity, Query query) => QueryOf entity query where
  -- | Extract the query instance ID from an entity.
  --
  -- This determines which query instance will be updated when the entity changes.
  -- Multiple entities may map to the same query instance (e.g., User and Order
  -- both contribute to the same UserOrders instance, keyed by user ID).
  queryId :: entity -> Uuid

  -- | Combine entity state with existing query state to produce a QueryAction.
  --
  -- Called whenever an entity changes. The function receives the current entity
  -- state and the existing query instance (if any), and returns a QueryAction
  -- indicating whether to update, delete, or take no action on the query.
  combine :: entity -> Maybe query -> QueryAction query


-- | Maps a query type to its constituent entity types.
--
-- This type family declares which entity types contribute to a query.
-- It is generated automatically by Template Haskell via 'deriveQuery'.
--
-- Example:
--
-- @
-- -- Generated by: deriveQuery ''UserOrders ['User, 'Order]
-- type instance EntitiesOf UserOrders = '[User, Order]
-- @
--
-- This is used by the query subscriber to know which entity events
-- should trigger updates to which queries.
type family EntitiesOf (query :: Type) :: [Type]
