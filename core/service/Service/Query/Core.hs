{-# LANGUAGE AllowAmbiguousTypes #-}

module Service.Query.Core (
  -- * Query Action
  QueryAction (..),

  -- * Query Typeclass
  Query (..),

  -- * Query Composition
  QueryOf (..),

  -- * Type Families
  EntitiesOf,
) where

import Auth.Claims (UserClaims)
import Basics
import Maybe (Maybe)
import Service.Entity.Core (Entity)
import Service.Query.Auth (QueryAuthError)
import Uuid (Uuid)


-- | Represents the outcome of combining an entity state with a query.
--
-- When an entity changes, we call 'combine' to determine what should happen
-- to the corresponding query instance:
--
-- * 'Update': Store or update the query instance with new data
-- * 'Delete': Remove the query instance from the store
-- * 'NoOp': Take no action (query instance remains unchanged)
--
-- Example:
--
-- @
-- combine user maybeExistingQuery =
--   case user.status of
--     Active -> Update (UserOrders { userId = user.id, orderCount = ... })
--     Deleted -> Delete
--     _ -> NoOp
-- @
data QueryAction query
  = Update query -- ^ Store or update this query instance
  | Delete -- ^ Remove this query instance from the store
  | NoOp -- ^ Take no action
  deriving (Eq, Show, Generic)


-- | Typeclass for query types (read models).
--
-- This typeclass defines authorization for queries:
--
-- * 'canAccessImpl': Checked before fetching data. "Can this user access this query type?"
-- * 'canViewImpl': Checked after fetching data. "Can this user view this specific instance?"
--
-- The user writes 'canAccess' and 'canView' functions in the query module,
-- and Template Haskell ('deriveQuery') wires them to these methods.
--
-- Example:
--
-- @
-- -- In the query module:
-- canAccess :: Maybe UserClaims -> Maybe QueryAuthError
-- canAccess = authenticatedAccess
--
-- canView :: Maybe UserClaims -> CartSummary -> Maybe QueryAuthError
-- canView = ownerOnly (.ownerId)
--
-- deriveQuery ''CartSummary [''CartEntity]
-- -- This generates:
-- -- instance Query CartSummary where
-- --   canAccessImpl = canAccess
-- --   canViewImpl = canView
-- @
class Query query where
  -- | Authorization check before fetching data.
  --
  -- Returns 'Nothing' if access is allowed, or 'Just error' to deny.
  -- This is called BEFORE any database/storage access.
  canAccessImpl :: Maybe UserClaims -> Maybe QueryAuthError

  -- | Authorization check after fetching data.
  --
  -- Returns 'Nothing' if viewing is allowed, or 'Just error' to deny.
  -- This is called AFTER data is fetched, allowing ownership checks.
  canViewImpl :: Maybe UserClaims -> query -> Maybe QueryAuthError


-- | Defines how an entity contributes to a query (read model).
--
-- Each entity that participates in a query must implement this typeclass,
-- specifying:
--
-- * 'queryId': Extract the query instance ID from an entity. For a UserOrders
--   query, both User and Order entities return the user's ID.
--
-- * 'combine': Merge the entity state with the existing query state (if any)
--   to produce a QueryAction indicating what should happen to the query.
--
-- Example:
--
-- @
-- instance QueryOf User UserOrders where
--   queryId user = user.id
--   combine user maybeExisting = Update UserOrders
--     { userId = user.id
--     , userName = user.name
--     , orders = maybeExisting |> Maybe.map (.orders) |> Maybe.withDefault Array.empty
--     }
--
-- instance QueryOf Order UserOrders where
--   queryId order = order.userId
--   combine order maybeExisting = case maybeExisting of
--     Just existing -> Update existing { orders = existing.orders |> Array.append order }
--     Nothing -> NoOp  -- Can't add order to non-existent user query
-- @
class (Entity entity, Query query) => QueryOf entity query where
  -- | Extract the query instance ID from an entity.
  --
  -- This determines which query instance will be updated when the entity changes.
  -- Multiple entities may map to the same query instance (e.g., User and Order
  -- both contribute to the same UserOrders instance, keyed by user ID).
  queryId :: entity -> Uuid

  -- | Combine entity state with existing query state to produce a QueryAction.
  --
  -- Called whenever an entity changes. The function receives the current entity
  -- state and the existing query instance (if any), and returns a QueryAction
  -- indicating whether to update, delete, or take no action on the query.
  combine :: entity -> Maybe query -> QueryAction query


-- | Maps a query type to its constituent entity types.
--
-- This type family declares which entity types contribute to a query.
-- It is generated automatically by Template Haskell via 'deriveQuery'.
--
-- Example:
--
-- @
-- -- Generated by: deriveQuery ''UserOrders ['User, 'Order]
-- type instance EntitiesOf UserOrders = '[User, Order]
-- @
--
-- This is used by the query subscriber to know which entity events
-- should trigger updates to which queries.
type family EntitiesOf (query :: Type) :: [Type]
