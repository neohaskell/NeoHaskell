{-# LANGUAGE ImplicitParams #-}
{-# LANGUAGE TemplateHaskell #-}

module Config.THSpec where

import Config (defineConfig, doc, defaultsTo, envVar, field, required)
import Core
import Test
import Text qualified


-- | Test config type generated by defineConfig
-- This tests that the TH macro generates valid code
$(defineConfig "TestConfig"
  [ field @Int "port"
      |> doc "HTTP port to listen on"
      |> defaultsTo (8080 :: Int)
      |> envVar "TEST_PORT"
  , field @Text "host"
      |> doc "Host to bind to"
      |> defaultsTo ("localhost" :: Text)
  , field @Text "databaseUrl"
      |> doc "Database connection URL"
      |> required
  ])


-- | Test that the generated type has the expected fields
testConfigHasFields :: TestConfig -> (Int, Text, Text)
testConfigHasFields config = (config.port, config.host, config.databaseUrl)


-- | Test that HasTestConfig type alias works with implicit params
useConfigImplicit :: (HasTestConfig) => Int
useConfigImplicit = ?config.port


spec :: Spec Unit
spec = do
  describe "Config.TH" do
    describe "defineConfig" do
      it "generates a data type with correct field names" \_ -> do
        let config = TestConfig 8080 "localhost" "postgres://localhost/test"
        config.port |> shouldBe 8080
        config.host |> shouldBe "localhost"
        config.databaseUrl |> shouldBe "postgres://localhost/test"

      it "generates a data type with correct field types" \_ -> do
        let config = TestConfig 3000 "0.0.0.0" "mysql://db"
        -- If types were wrong, this wouldn't compile
        let portVal :: Int = config.port
        let hostVal :: Text = config.host
        let dbVal :: Text = config.databaseUrl
        portVal |> shouldBe 3000
        hostVal |> shouldBe "0.0.0.0"
        dbVal |> shouldBe "mysql://db"

      it "generates HasTestConfig type alias for implicit params" \_ -> do
        let config = TestConfig 9000 "test" "db"
        let result = let ?config = config in useConfigImplicit
        result |> shouldBe 9000

      it "generated type has Show instance" \_ -> do
        let config = TestConfig 8080 "localhost" "db"
        let shown = toText config
        -- Should contain the type name and field values
        shown |> shouldSatisfy (\s -> Text.contains "TestConfig" s)
        shown |> shouldSatisfy (\s -> Text.contains "8080" s)

    describe "field validation" do
      -- Note: These tests verify compile-time behavior
      -- Invalid configs would fail to compile, so we test valid configs work
      it "accepts field with doc and defaultsTo" \_ -> do
        -- TestConfig.port has doc and defaultsTo - compiles successfully
        let config = TestConfig 8080 "localhost" "db"
        config.port |> shouldBe 8080

      it "accepts field with doc and required" \_ -> do
        -- TestConfig.databaseUrl has doc and required - compiles successfully
        let config = TestConfig 8080 "localhost" "postgres://test"
        config.databaseUrl |> shouldBe "postgres://test"

    describe "env var naming" do
      -- Note: We can't directly test toEnvVarName since it's internal
      -- But we can verify the envVar modifier is respected
      it "uses explicit envVar when provided" \_ -> do
        -- TestConfig.port has envVar "TEST_PORT"
        -- This test verifies the config compiles with explicit env var
        let config = TestConfig 8080 "localhost" "db"
        config.port |> shouldBe 8080

      it "auto-generates env var from field name" \_ -> do
        -- TestConfig.host doesn't have explicit envVar
        -- It should auto-generate HOST
        -- TestConfig.databaseUrl should auto-generate DATABASE_URL
        let config = TestConfig 8080 "localhost" "db"
        config.host |> shouldBe "localhost"
