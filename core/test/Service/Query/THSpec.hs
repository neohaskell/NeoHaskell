{-# LANGUAGE TemplateHaskell #-}

module Service.Query.THSpec where

import Core
import Data.Proxy (Proxy (..))
import GHC.TypeLits (KnownSymbol, symbolVal)
import Json qualified
import Service.Query.Core (EntitiesOf, Query, QueryAction (..), QueryOf (..))
import Service.Query.TH (deriveQuery)
import Test
import Text qualified
import Uuid qualified


-- ============================================================================
-- Test Entity: User
-- ============================================================================

data UserEntity = UserEntity
  { userId :: Uuid,
    userName :: Text
  }
  deriving (Eq, Show, Generic)


instance Json.ToJSON UserEntity
instance Json.FromJSON UserEntity


data UserEvent
  = UserCreated Uuid Text
  | UserRenamed Text
  deriving (Eq, Show, Generic)


instance Json.ToJSON UserEvent
instance Json.FromJSON UserEvent


type instance EventOf UserEntity = UserEvent


instance Entity UserEntity where
  initialStateImpl = UserEntity {userId = Uuid.nil, userName = ""}
  updateImpl event entity = case event of
    UserCreated uid name -> entity {userId = uid, userName = name}
    UserRenamed name -> entity {userName = name}


-- ============================================================================
-- Test Entity: Order
-- ============================================================================

data OrderEntity = OrderEntity
  { orderId :: Uuid,
    orderUserId :: Uuid,
    orderTotal :: Int
  }
  deriving (Eq, Show, Generic)


instance Json.ToJSON OrderEntity
instance Json.FromJSON OrderEntity


data OrderEvent
  = OrderPlaced Uuid Uuid Int
  deriving (Eq, Show, Generic)


instance Json.ToJSON OrderEvent
instance Json.FromJSON OrderEvent


type instance EventOf OrderEntity = OrderEvent


instance Entity OrderEntity where
  initialStateImpl = OrderEntity {orderId = Uuid.nil, orderUserId = Uuid.nil, orderTotal = 0}
  updateImpl event entity = case event of
    OrderPlaced oid uid total -> entity {orderId = oid, orderUserId = uid, orderTotal = total}


-- ============================================================================
-- Test Query: UserOrders
-- ============================================================================

data UserOrders = UserOrders
  { userOrdersId :: Uuid,
    userOrdersName :: Text,
    userOrdersTotal :: Int
  }
  deriving (Eq, Show, Generic)


instance Json.ToJSON UserOrders
instance Json.FromJSON UserOrders


-- Use TH to derive Query instances
deriveQuery ''UserOrders [''UserEntity, ''OrderEntity]


-- Manual QueryOf instances (these are NOT generated by deriveQuery)
instance QueryOf UserEntity UserOrders where
  queryId user = user.userId
  combine user maybeExisting = case maybeExisting of
    Just existing -> Update existing {userOrdersName = user.userName}
    Nothing -> Update UserOrders {userOrdersId = user.userId, userOrdersName = user.userName, userOrdersTotal = 0}


instance QueryOf OrderEntity UserOrders where
  queryId order = order.orderUserId
  combine order maybeExisting = case maybeExisting of
    Just existing -> Update existing {userOrdersTotal = existing.userOrdersTotal + order.orderTotal}
    Nothing -> NoOp -- Can't add order to non-existent user


-- ============================================================================
-- Test Query: SimpleQuery (single entity)
-- ============================================================================

data SimpleQuery = SimpleQuery
  { simpleQueryId :: Uuid,
    simpleQueryValue :: Int
  }
  deriving (Eq, Show, Generic)


instance Json.ToJSON SimpleQuery
instance Json.FromJSON SimpleQuery


deriveQuery ''SimpleQuery [''UserEntity]


instance QueryOf UserEntity SimpleQuery where
  queryId user = user.userId
  combine user _maybeExisting =
    Update SimpleQuery {simpleQueryId = user.userId, simpleQueryValue = 42}


-- ============================================================================
-- Tests
-- ============================================================================

spec :: Spec Unit
spec = do
  describe "Service.Query.TH" do
    describe "deriveQuery" do
      describe "Query instance" do
        it "generates Query instance for UserOrders" \_ -> do
          -- This test verifies compilation - if it compiles, the instance exists
          -- We test this by using a function that requires the Query constraint
          let _ = queryInstanceExists (Proxy :: Proxy UserOrders)
          pass

        it "generates Query instance for SimpleQuery" \_ -> do
          let _ = queryInstanceExists (Proxy :: Proxy SimpleQuery)
          pass

      describe "NameOf type instance" do
        it "generates kebab-case name for UserOrders" \_ -> do
          let name = nameOfQuery (Proxy :: Proxy UserOrders)
          name |> shouldBe "user-orders"

        it "generates kebab-case name for SimpleQuery" \_ -> do
          let name = nameOfQuery (Proxy :: Proxy SimpleQuery)
          name |> shouldBe "simple-query"

      describe "EntitiesOf type instance" do
        it "generates correct entity list for UserOrders (two entities)" \_ -> do
          let entityCount = entitiesOfCount (Proxy :: Proxy UserOrders)
          entityCount |> shouldBe 2

        it "generates correct entity list for SimpleQuery (one entity)" \_ -> do
          let entityCount = entitiesOfCount (Proxy :: Proxy SimpleQuery)
          entityCount |> shouldBe 1

      describe "KnownHash instance" do
        it "generates consistent hash for UserOrders" \_ -> do
          let hash1 = hashVal (Proxy :: Proxy "UserOrders")
          let hash2 = hashVal (Proxy :: Proxy "UserOrders")
          hash1 |> shouldBe hash2

        it "generates different hashes for different queries" \_ -> do
          let hash1 = hashVal (Proxy :: Proxy "UserOrders")
          let hash2 = hashVal (Proxy :: Proxy "SimpleQuery")
          (hash1 != hash2) |> shouldBe True

      describe "QueryOf instances work correctly" do
        it "User contributes to UserOrders query" \_ -> do
          let user = UserEntity {userId = Uuid.nil, userName = "Alice"}
          let action = combine @UserEntity @UserOrders user Nothing
          case action of
            Update query -> query.userOrdersName |> shouldBe "Alice"
            _ -> fail "Expected Update action"

        it "Order contributes to UserOrders query" \_ -> do
          let existingQuery = UserOrders {userOrdersId = Uuid.nil, userOrdersName = "Alice", userOrdersTotal = 100}
          let order = OrderEntity {orderId = Uuid.nil, orderUserId = Uuid.nil, orderTotal = 50}
          let action = combine @OrderEntity @UserOrders order (Just existingQuery)
          case action of
            Update query -> query.userOrdersTotal |> shouldBe 150
            _ -> fail "Expected Update action"

        it "Order returns NoOp when user query doesn't exist" \_ -> do
          let order = OrderEntity {orderId = Uuid.nil, orderUserId = Uuid.nil, orderTotal = 50}
          let action = combine @OrderEntity @UserOrders order Nothing
          case action of
            NoOp -> pass
            _ -> fail "Expected NoOp action"


-- Helper function to verify Query instance exists
queryInstanceExists :: forall query. (Query query) => Proxy query -> ()
queryInstanceExists _ = ()


-- Helper to get the name of a query type using NameOf
nameOfQuery :: forall query. (KnownSymbol (NameOf query)) => Proxy query -> Text
nameOfQuery _ = symbolVal (Proxy :: Proxy (NameOf query)) |> Text.fromLinkedList


-- Helper to count entities in EntitiesOf (uses type-level list length)
class CountEntities (entities :: [Type]) where
  countEntities :: Proxy entities -> Int

instance CountEntities '[] where
  countEntities _ = 0

instance (CountEntities rest) => CountEntities (entity ': rest) where
  countEntities _ = 1 + countEntities (Proxy :: Proxy rest)


entitiesOfCount :: forall query. (CountEntities (EntitiesOf query)) => Proxy query -> Int
entitiesOfCount _ = countEntities (Proxy :: Proxy (EntitiesOf query))
