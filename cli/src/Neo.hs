{-# OPTIONS_GHC -fno-warn-name-shadowing #-}

module Neo (
  run,
  fromText,
) where

import Array qualified
import Command qualified
import Core
import File qualified
import Json qualified
import Map qualified
import Path qualified
import Subprocess (Completion (..))
import Subprocess qualified
import Text qualified
import Version qualified


data CommonFlags = CommonFlags
  { projectFile :: Path
  }
  deriving (Show, Eq, Ord)


data NeoCommand
  = Build CommonFlags
  deriving (Show, Eq, Ord)


run :: IO ()
run = do
  let parser =
        Command.CommandOptions
          { name = "neo",
            description = "NeoHaskell's console helper",
            version = Just [Core.version|0.5.0|],
            decoder = commandsParser
          }
  cmd <- Command.parseHandler parser
  handleCommand cmd


commandsParser :: Command.OptionsParser NeoCommand
commandsParser = do
  let build =
        Command.CommandOptions
          { name = "build",
            description = "build a file or directory",
            version = Nothing,
            decoder = buildParser
          }
  Command.commands
    (Array.fromLinkedList [build])


buildParser :: Command.OptionsParser NeoCommand
buildParser = do
  common <- flagsParser
  pure (Build common)


flagsParser :: Command.OptionsParser CommonFlags
flagsParser = do
  projectFilePath <-
    Command.path
      Command.PathConfig
        { metavar = "PATH",
          short = 'c',
          help = "Path to the project configuration file",
          long = "projectConfig",
          value = Just [path|neo.json|]
        }
  pure (CommonFlags {projectFile = projectFilePath})


handleCommand :: NeoCommand -> IO ()
handleCommand command =
  case command of
    Build flags -> do
      let readOpts = File.ReadOptions {path = flags.projectFile}
      configTxt <- File.readTextHandler readOpts
      case configTxt of
        Err err -> toPrettyText err |> print
        Ok txt -> do
          case Json.decodeText txt of
            Err err -> print err
            Ok config -> handleBuild config


handleBuild :: ProjectConfiguration -> Task BuildError ()
handleBuild config = do
  let nixFile = makeNixFile config
  let cabalFile = makeCabalFile config
  let rootFolder = [path|sandbox|]
  let nixPath = [path|devenv.nix|]
  let cabalPath = [path|example.cabal|]
  let nixFileName =
        Array.fromLinkedList [rootFolder, nixPath]
          |> Path.joinPaths
  let cabalFileName =
        Array.fromLinkedList [rootFolder, cabalPath]
          |> Path.joinPaths
  res1 <- File.writeText nixFileName nixFile
  case res1 of
    Err err ->
      panic (toPrettyText err)
    Ok _ -> do
      res2 <- File.writeText cabalFileName cabalFile
      case res2 of
        Err err -> panic (toPrettyText err)
        Ok _ -> do
          let openOpts =
                Subprocess.OpenOptions
                  { executable = "cabal",
                    arguments = Array.fromLinkedList ["build"],
                    directory = rootFolder
                  }
          completion <- Subprocess.openHandler openOpts
          if completion.exitCode != 0
            then do
              let err = completion.stderr
              panic
                [fmt|Oops, the build failed:

              {err}|]
            else print completion.stdout


makeNixFile :: ProjectConfiguration -> Text
makeNixFile _ =
  -- FIXME: inflect properly the name of the project in the different places of the nix file
  [fmt|{{ inputs, pkgs, ... }}:

{{
  packages = with pkgs; [
    haskellPackages.implicit-hie
    haskellPackages.doctest
  ];
  languages.haskell.enable = true;
}}
  |]


makeCabalFile :: ProjectConfiguration -> Text
makeCabalFile ProjectConfiguration {name, version, description, license, author, dependencies} = do
  let vText = Version.toText version
  let makeDep (k, v)
        | v |> Text.trim |> Text.startsWith "^" = [fmt|{k} ^>= {v |> Text.replace "^" ""}|]
        | otherwise = [fmt|{k} == {v}|]
  let deps =
        dependencies
          |> Map.entries
          |> Array.map makeDep
          |> Array.push [fmt|nhcore|]
          |> Text.joinWith ", "
  [fmt|cabal-version:      3.4
-- THIS CABAL FILE IS AUTOGENERATED BY `neo`, THE NEOHASKELL CLI TOOL.
-- YOU SHOULD NOT MODIFY IT, AS IT WILL BE REGENERATED NEXT TIME `neo` RUNS.
-- THE REASON FOR THIS FILE TO EXIST IS THAT
-- CURRENT HASKELL IDE TOOLING CAN PICK UP
-- THE NEOHASKELL PROJECT AS IF IT WAS A
-- REGULAR HASKELL PROJECT.
--
-- IF YOU HAVE A SPECIFIC NEED TO MODIFY THIS
-- FILE, PLEASE STATE SO EITHER IN A GITHUB
-- ISSUE: https://github.com/NeoHaskell/NeoHaskell/issues
-- OR IN THE NEOHASKELL DISCORD SERVER.
-- YOU CAN JOIN IT THROUGH THE LINK IN
-- https://neohaskell.org
name:               {name}
version:            {vText}
synopsis:           {description}
license:            {license}
author:             {author}

common common_cfg
    ghc-options:    -Wall
                    -Werror
                    -threaded
    default-language: GHC2021
    default-extensions:
      ApplicativeDo
      BlockArguments
      DataKinds
      NoImplicitPrelude
      TemplateHaskell
      DeriveDataTypeable
      QuasiQuotes
      QualifiedDo
      ImpredicativeTypes
      ImportQualifiedPost
      OverloadedStrings
      OverloadedLabels
      OverloadedRecordDot
      DuplicateRecordFields
      PackageImports
      NamedFieldPuns
      Strict
      TypeFamilies

    build-depends:
      {deps}

library
    import:           common_cfg
    exposed-modules:
      Neo,
    -- other-modules:
    -- other-extensions:
    hs-source-dirs:   src

executable neo
    import:           common_cfg
    main-is:          Main.hs
    build-depends:
        {name}
    hs-source-dirs:   app

test-suite {name}-test
    import:           common_cfg
    type:             exitcode-stdio-1.0
    hs-source-dirs:   test
    main-is:          Main.hs
    build-depends:
        {name}
  |]


-- Project config

data ProjectConfiguration = ProjectConfiguration
  { name :: Text,
    version :: Version,
    description :: Text,
    author :: Text,
    license :: Text,
    dependencies :: Map Text Text
  }
  deriving (Show, Eq, Ord, Generic)


-- | We allow the `ProjectConfiguration` type to be converted from JSON.
instance Json.FromJSON ProjectConfiguration


-- | We allow the `ProjectConfiguration` type to be converted to JSON.
instance Json.ToJSON ProjectConfiguration


-- | The `ProjectConfiguration.fromText` function allows you to convert a JSON
-- `Text` value to a `ProjectConfiguration` value.
--
-- >>> fromText "{\"name\":\"neo\",\"version\":\"0.5.0\",\"description\":\"NeoHaskell's console helper\",\"author\":\"NeoHaskell\",\"license\":\"MIT\"}"
-- Ok (ProjectConfiguration {name = "neo", version = [version|0.5.0|], description = "NeoHaskell's console helper", author = "NeoHaskell", license = "MIT"})
--
-- >>> fromText "some invalid json"
-- Err "Error in $: not enough input"
fromText :: Text -> Result Text ProjectConfiguration
fromText someText = Json.decodeText someText
